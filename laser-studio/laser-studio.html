<!DOCTYPE html>
<html>
<head>
    <!-- Primary Meta Tags -->
    <title>Laser Studio</title>
    <meta name="title" content="Laser Studio" />
    <meta name="description" content="Laser Studio for creating and minting ar://playdead compatible laser NFTs." />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://experimental_playdead.permagate.io/" />
    <meta property="og:title" content="Laser Studio" />
    <meta property="og:description" content="Laser Studio for creating and minting ar://playdead compatible laser NFTs." />
    <meta property="og:image" content="https://arweave.net/RnSVS1mJevWaxYY9W9YlgYPVzPA9Ona8yOd8zxYk8ms" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary" />
    <meta property="twitter:url" content="https://experimental_playdead.permagate.io/" />
    <meta property="twitter:title" content="Laser Studio" />
    <meta property="twitter:description" content="Laser Studio for creating and minting ar://playdead compatible laser NFTs." />
    <meta property="twitter:image" content="https://arweave.net/RnSVS1mJevWaxYY9W9YlgYPVzPA9Ona8yOd8zxYk8ms" />

    <!-- Favicon -->
    <link rel="icon" href="https://arweave.net/RnSVS1mJevWaxYY9W9YlgYPVzPA9Ona8yOd8zxYk8ms" type="image/x-icon">   

    <style>

        body { 
            margin: 0; 
            padding: 20px; 
            font-family: sans-serif;
            background: #000;
            color: #fff;
        }
        .container { 
            display: flex; 
            gap: 20px;
            height: 100vh;
        }
        .controls { 
            width: 300px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 8px;
        }
        .preview { 
            flex-grow: 1;
            position: relative;
        }
        canvas { 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .form-group { 
            margin-bottom: 15px;
        }
        label { 
            display: block; 
            margin-bottom: 5px;
            color: #fff;
        }
        input { 
            width: 100%;
            padding: 8px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            border-radius: 4px;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #ff4500;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #ff6347;
        }
        .mode-specific {
            display: none;
        }
        .mode-specific.active {
            display: block;
        }

        /* Add these new styles for the mint button and modal */
        .mint-button {
            background: #666;
            color: white;
            padding: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
            font-size: 16px;
            width: 100%;
        }

        .mint-button:hover {
            background: #777;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        .modal-content {
            background-color: #222;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            width: 300px;
            text-align: center;
            color: white;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: white;
        }

        /* Add recording controls styles */
        .recording-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #444;
        }

        .recording-controls button {
            background: #444;
            margin-bottom: 10px;
        }

        .recording-controls button.recording {
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .timeline {
            height: 30px;
            background: #222;
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .timeline-progress {
            height: 100%;
            background: #333;
            width: 0%;
            transition: width 0.1s linear;
        }

        .keyframe-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #666;
            top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>Laser Studio v2</h2>
            
            <div class="form-group">
                <label>Mode:</label>
                <select id="mode">
                    <option value="classic">Classic Lasers</option>
                    <option value="ripple">Ripple Effect</option>
                    <option value="spotlights">Spotlights</option>
                </select>
            </div>

            <!-- Classic Mode Controls -->
            <div id="classic-controls" class="mode-specific active">
                <div class="form-group">
                    <label>Number of Lasers:</label>
                    <input type="number" id="laserCount" value="15" min="1" max="50">
                </div>
            </div>

            <!-- Ripple Mode Controls -->
            <div id="ripple-controls" class="mode-specific">
                <div class="form-group">
                    <label>Number of Ripples:</label>
                    <input type="number" id="rippleCount" value="5" min="1" max="10">
                </div>
            </div>

            <!-- Spotlight Mode Controls -->
            <div id="spotlight-controls" class="mode-specific">
                <div class="form-group">
                    <label>Number of Spotlights:</label>
                    <input type="number" id="spotlightCount" value="6" min="1" max="12">
                </div>
                <div class="form-group">
                    <label>Show Fog Effect:</label>
                    <input type="checkbox" id="showFog" checked>
                </div>
            </div>

            <!-- Common Controls -->
            <div class="form-group">
                <label>Speed:</label>
                <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
            </div>

            <div class="form-group">
                <label>Color Scheme:</label>
                <select id="colorScheme">
                    <option value="0">Red/Orange/Yellow</option>
                    <option value="1">Aqua/Cyan/Blue</option>
                    <option value="2">Purple/Magenta/Red</option>
                    <option value="3">Orange/Yellow/Green</option>
                    <option value="4">Blue/Azure/Purple</option>
                </select>
            </div>

            <div class="form-group">
                <label>Intensity:</label>
                <input type="range" id="intensity" min="0" max="1" step="0.1" value="0.75">
            </div>

            <div class="recording-controls">
                <button id="recordButton">Start Recording</button>
                <button id="playButton" disabled>Play Recording</button>
                <button id="saveButton" disabled>Save Recording</button>
                <div class="timeline">
                    <div class="timeline-progress"></div>
                </div>
            </div>

            <button id="reset">Reset Effects</button>
            <button class="mint-button" id="mintButton">Mint Laser!!!</button>
        </div>
        <div class="preview">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <!-- Add the modal -->
    <div id="mintModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Coming Soon!</h2>
            <p>NFT minting functionality will be available soon.</p>
        </div>
    </div>

    <script>
        // Core classes and state
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentMode = 'classic';
        let animationFrame;
        let state = {};

        // Color schemes
        const colorSchemes = [
            [350, 45, 85],      // Red, Orange, Yellow
            [180, 210, 240],    // Aqua, Cyan, Blue
            [280, 315, 350],    // Purple, Magenta, Red
            [45, 85, 125],      // Orange, Yellow, Green
            [200, 240, 280]     // Blue, Azure, Purple
        ];

        // Classic Laser Mode
        class Laser {
            constructor(minSpeed, maxSpeed, colorIndex = 0) {
                this.reset(minSpeed, maxSpeed, colorIndex);
            }

            reset(minSpeed, maxSpeed, colorIndex) {
                this.x1 = Math.random() * canvas.width;
                this.y1 = Math.random() * canvas.height;
                this.x2 = Math.random() * canvas.width;
                this.y2 = Math.random() * canvas.height;
                this.vx1 = Math.random() * (maxSpeed - minSpeed) + minSpeed;
                this.vy1 = Math.random() * (maxSpeed - minSpeed) + minSpeed;
                this.vx2 = Math.random() * (maxSpeed - minSpeed) + minSpeed;
                this.vy2 = Math.random() * (maxSpeed - minSpeed) + minSpeed;
                this.colorIndex = colorIndex;
                this.hue = 0;
                this.targetHue = 0;
                this.colorTransitionSpeed = Math.random() * 0.02 + 0.01;
                this.baseWidth = Math.random() + 1;
                this.currentAlpha = 1;
            }

            update(intensity, currentColors, speedMultiplier) {
                this.x1 += this.vx1 * speedMultiplier;
                this.y1 += this.vy1 * speedMultiplier;
                this.x2 += this.vx2 * speedMultiplier;
                this.y2 += this.vy2 * speedMultiplier;

                if (this.x1 < 0 || this.x1 > canvas.width) this.vx1 *= -1;
                if (this.y1 < 0 || this.y1 > canvas.height) this.vy1 *= -1;
                if (this.x2 < 0 || this.x2 > canvas.width) this.vx2 *= -1;
                if (this.y2 < 0 || this.y2 > canvas.height) this.vy2 *= -1;

                this.targetHue = currentColors[this.colorIndex];
                this.hue += (this.targetHue - this.hue) * this.colorTransitionSpeed;
            }

            draw(ctx) {
                ctx.beginPath();
                const glowGradient = ctx.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
                glowGradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, 0.1)`);
                glowGradient.addColorStop(1, `hsla(${this.hue + 30}, 100%, 50%, 0.05)`);
                ctx.strokeStyle = glowGradient;
                ctx.lineWidth = this.baseWidth * 3;
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();

                ctx.beginPath();
                const mainGradient = ctx.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
                mainGradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, ${this.currentAlpha})`);
                mainGradient.addColorStop(1, `hsla(${this.hue + 30}, 100%, 50%, ${this.currentAlpha * 0.5})`);
                ctx.strokeStyle = mainGradient;
                ctx.lineWidth = this.baseWidth;
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();
            }
        }

        // Ripple Mode
        class Ripple {
            constructor(index, total) {
                this.radius = index * 50;
                this.opacity = 1 - (index * 0.2);
                this.speed = 3 + (index * 0.5);
                this.hue = (index * 60) % 360;
            }

            update(maxRadius, intensity, speedMultiplier) {
                this.radius += this.speed * speedMultiplier * (1 + intensity);
                if (this.radius > maxRadius) {
                    this.radius = 0;
                    this.hue = (this.hue + 60) % 360;
                }
            }

            draw(ctx, centerX, centerY, intensity) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.radius, 0, Math.PI * 2);
                const alpha = this.opacity * (0.5 + intensity * 0.5);
                const brightness = 50 + intensity * 30;
                ctx.strokeStyle = `hsla(${this.hue}, 100%, ${brightness}%, ${alpha})`;
                ctx.lineWidth = 2 + intensity * 3;
                ctx.stroke();
            }
        }

        // Spotlight Mode
        class Spotlight {
            constructor(index, total, isUplight = false) {
                this.x = canvas.width * ((index + 0.5) / total);
                this.y = isUplight ? canvas.height + 20 : -20;
                this.baseAngle = isUplight ? -Math.PI * 0.4 : Math.PI * 0.4;
                this.angle = this.baseAngle;
                this.sweepSpeed = Math.random() * 0.01 + 0.005;
                this.sweepAngle = Math.random() * Math.PI * 2;
                this.sweepRange = Math.PI * 0.25;
                this.colorIndex = index % 3;
                this.hue = 0;
                this.beamLength = Math.max(canvas.width, canvas.height) * 1.2;
                this.beamWidth = Math.random() * 20 + 15;
            }

            update(intensity, currentColors, speedMultiplier) {
                this.sweepAngle += this.sweepSpeed * speedMultiplier;
                this.angle = this.baseAngle + Math.sin(this.sweepAngle) * this.sweepRange;
                this.hue = currentColors[this.colorIndex];
            }

            draw(ctx, intensity) {
                const endX = this.x + Math.cos(this.angle) * this.beamLength;
                const endY = this.y + Math.sin(this.angle) * this.beamLength;
                
                const gradient = ctx.createLinearGradient(this.x, this.y, endX, endY);
                gradient.addColorStop(0, `hsla(${this.hue}, 70%, 50%, ${0.3 + intensity * 0.3})`);
                gradient.addColorStop(1, `hsla(${this.hue}, 50%, 50%, 0)`);

                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.beamWidth;
                ctx.stroke();
            }
        }

        // Mode Initialization Functions
        const modes = {
            classic: {
                init: () => {
                    const count = parseInt(document.getElementById('laserCount').value);
                    return {
                        lasers: Array.from({ length: count }, (_, i) => new Laser(2, 4, i % 3))
                    };
                },
                animate: (state, intensity, currentColors, speedMultiplier) => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    state.lasers.forEach(laser => {
                        laser.update(intensity, currentColors, speedMultiplier);
                        laser.draw(ctx);
                    });
                }
            },
            ripple: {
                init: () => {
                    const count = parseInt(document.getElementById('rippleCount').value);
                    return {
                        ripples: Array.from({ length: count }, (_, i) => new Ripple(i, count))
                    };
                },
                animate: (state, intensity, currentColors, speedMultiplier) => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const maxRadius = Math.max(canvas.width, canvas.height) * 0.8;
                    
                    state.ripples.forEach(ripple => {
                        ripple.update(maxRadius, intensity, speedMultiplier);
                        ripple.draw(ctx, centerX, centerY, intensity);
                    });
                }
            },
            spotlights: {
                init: () => {
                    const count = parseInt(document.getElementById('spotlightCount').value);
                    const showFog = document.getElementById('showFog').checked;
                    
                    return {
                        spotlights: Array.from({ length: count }, (_, i) => new Spotlight(i, count, false)),
                        uplights: Array.from({ length: Math.floor(count/2) }, (_, i) => new Spotlight(i, Math.floor(count/2), true)),
                        fogParticles: showFog ? Array.from({ length: 100 }, () => ({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            size: Math.random() * 150 + 50,
                            vx: (Math.random() - 0.5) * 0.2,
                            vy: (Math.random() - 0.5) * 0.1 - 0.1,
                            alpha: Math.random() * 0.3
                        })) : []
                    };
                },
                animate: (state, intensity, currentColors, speedMultiplier) => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Update fog
                    if (state.fogParticles) {
                        state.fogParticles.forEach(particle => {
                            particle.x += particle.vx * speedMultiplier;
                            particle.y += particle.vy * speedMultiplier;
                            
                            if (particle.y < -particle.size) {
                                particle.y = canvas.height + particle.size;
                                particle.x = Math.random() * canvas.width;
                            }
                            if (particle.x < -particle.size) particle.x = canvas.width + particle.size;
                            if (particle.x > canvas.width + particle.size) particle.x = -particle.size;
                            
                            const gradient = ctx.createRadialGradient(
                                particle.x, particle.y, 0,
                                particle.x, particle.y, particle.size
                            );
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${particle.alpha})`);
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            
                            ctx.beginPath();
                            ctx.fillStyle = gradient;
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                    
                    // Update and draw lights
                    const allLights = [...(state.spotlights || []), ...(state.uplights || [])];
                    allLights.forEach(light => {
                        light.update(intensity, currentColors, speedMultiplier);
                        light.draw(ctx, intensity);
                    });
                }
            }
        };

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        function animate() {
            const intensity = parseFloat(document.getElementById('intensity').value);
            const speedMultiplier = parseFloat(document.getElementById('speed').value);
            const currentScheme = parseInt(document.getElementById('colorScheme').value);
            
            modes[currentMode].animate(state, intensity, colorSchemes[currentScheme], speedMultiplier);
            animationFrame = requestAnimationFrame(animate);
        }

        // Event Listeners
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('mode').addEventListener('change', (e) => {
            currentMode = e.target.value;
            // Show/hide mode-specific controls
            document.querySelectorAll('.mode-specific').forEach(el => {
                el.classList.remove('active');
            });
            const modeControls = document.getElementById(`${currentMode}-controls`);
            if (modeControls) {
                modeControls.classList.add('active');
            }
            // Reset state with new mode
            state = modes[currentMode].init();
        });

        document.getElementById('reset').addEventListener('click', () => {
            state = modes[currentMode].init();
        });

        // Initialize
        resizeCanvas();
        state = modes.classic.init();
        animate();

        // Add this at the end of the script section
        const modal = document.getElementById('mintModal');
        const mintButton = document.getElementById('mintButton');
        const closeButton = document.getElementsByClassName('close')[0];

        mintButton.onclick = function() {
            modal.style.display = 'block';
        }

        closeButton.onclick = function() {
            modal.style.display = 'none';
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        // Recording system
        let recording = false;
        let sequence = null;
        let recordingStartTime = 0;
        let keyframes = [];

        function captureState() {
            return {
                timestamp: Date.now() - recordingStartTime,
                mode: currentMode,
                colorScheme: parseInt(document.getElementById('colorScheme').value),
                intensity: parseFloat(document.getElementById('intensity').value),
                speed: parseFloat(document.getElementById('speed').value),
                params: getCurrentModeParams()
            };
        }

        function getCurrentModeParams() {
            switch(currentMode) {
                case 'classic':
                    return {
                        laserCount: parseInt(document.getElementById('laserCount').value)
                    };
                case 'ripple':
                    return {
                        rippleCount: parseInt(document.getElementById('rippleCount').value)
                    };
                case 'spotlights':
                    return {
                        spotlightCount: parseInt(document.getElementById('spotlightCount').value),
                        showFog: document.getElementById('showFog').checked
                    };
                default:
                    return {};
            }
        }

        // Add event listeners for all controls to capture changes
        document.querySelectorAll('input, select').forEach(element => {
            element.addEventListener('change', () => {
                if (recording) {
                    keyframes.push(captureState());
                    addKeyframeMarker();
                }
            });

            if (element.type === 'range') {
                element.addEventListener('input', () => {
                    if (recording) {
                        keyframes.push(captureState());
                        addKeyframeMarker();
                    }
                });
            }
        });

        function addKeyframeMarker() {
            const timeline = document.querySelector('.timeline');
            const progress = (Date.now() - recordingStartTime) / 30000 * 100; // 30 seconds max
            const marker = document.createElement('div');
            marker.className = 'keyframe-marker';
            marker.style.left = `${progress}%`;
            timeline.appendChild(marker);
        }

        // Recording controls
        const recordButton = document.getElementById('recordButton');
        const playButton = document.getElementById('playButton');
        const saveButton = document.getElementById('saveButton');
        const timelineProgress = document.querySelector('.timeline-progress');

        recordButton.addEventListener('click', () => {
            if (!recording) {
                // Start recording
                recording = true;
                recordingStartTime = Date.now();
                keyframes = [captureState()]; // Capture initial state
                recordButton.textContent = 'Stop Recording';
                recordButton.classList.add('recording');
                playButton.disabled = true;
                saveButton.disabled = true;
                
                // Clear existing markers
                document.querySelectorAll('.keyframe-marker').forEach(marker => marker.remove());
                addKeyframeMarker();

                // Start timeline progress
                let progressInterval = setInterval(() => {
                    const progress = (Date.now() - recordingStartTime) / 30000 * 100;
                    timelineProgress.style.width = `${Math.min(progress, 100)}%`;
                    
                    if (progress >= 100) {
                        stopRecording();
                        clearInterval(progressInterval);
                    }
                }, 100);
            } else {
                stopRecording();
            }
        });

        function stopRecording() {
            recording = false;
            recordButton.textContent = 'Start Recording';
            recordButton.classList.remove('recording');
            playButton.disabled = false;
            saveButton.disabled = false;
            timelineProgress.style.width = '0%';
        }

        playButton.addEventListener('click', () => {
            let currentFrame = 0;
            
            function applyKeyframe(frame) {
                const kf = keyframes[frame];
                
                // Apply all parameters
                document.getElementById('mode').value = kf.mode;
                document.getElementById('colorScheme').value = kf.colorScheme;
                document.getElementById('intensity').value = kf.intensity;
                document.getElementById('speed').value = kf.speed;
                
                // Apply mode-specific parameters
                if (kf.params) {
                    Object.entries(kf.params).forEach(([key, value]) => {
                        const element = document.getElementById(key);
                        if (element) {
                            if (element.type === 'checkbox') {
                                element.checked = value;
                            } else {
                                element.value = value;
                            }
                        }
                    });
                }
                
                // Update mode
                if (frame === 0 || kf.mode !== keyframes[frame - 1].mode) {
                    document.getElementById('mode').dispatchEvent(new Event('change'));
                }
            }

            function playSequence() {
                if (currentFrame < keyframes.length) {
                    applyKeyframe(currentFrame);
                    
                    const progress = keyframes[currentFrame].timestamp / 30000 * 100;
                    timelineProgress.style.width = `${progress}%`;
                    
                    currentFrame++;
                    setTimeout(playSequence, 
                        currentFrame < keyframes.length ? 
                        keyframes[currentFrame].timestamp - keyframes[currentFrame - 1].timestamp : 
                        0);
                } else {
                    timelineProgress.style.width = '0%';
                }
            }

            playSequence();
        });

        saveButton.addEventListener('click', () => {
            const sequence = {
                duration: keyframes[keyframes.length - 1].timestamp,
                keyframes: keyframes
            };
            
            const blob = new Blob([JSON.stringify(sequence, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'laser-sequence.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html> 